# Discord Anti-Spam Bot: Supabase Error Handling

## Issue Overview

We encountered an issue with the Supabase repository implementation where the bot was failing to create new server configurations. The error occurred when trying to fetch an existing server configuration that didn't exist yet, causing the try-catch block to fail early before upserting a new server config.

## Root Cause Analysis

1. **PostgrestError Handling**: When using Supabase's `.single()` method, it throws a `PostgrestError` with code 'PGRST116' when no rows are found, rather than returning null.

2. **Repository Implementation**: Our repository methods were throwing errors when no rows were found, rather than treating this as a valid "not found" case and returning null.

3. **UUID Validation**: When creating a new server configuration, we were including a non-UUID formatted ID ('local-' + guildId) which caused a database validation error when trying to insert it.

## Solution Implemented

### 1. Proper Error Handling for "Not Found" Cases

We modified all repository methods that use `.single()` to specifically handle the 'PGRST116' error code as a valid "not found" case:

```typescript
// Handle the specific "no rows" error as a valid "not found" case
if (error && error.code === 'PGRST116') {
  return null;
} else if (error) {
  throw error;
}
```

This change was applied to:

- `findByGuildId` in ServerRepository
- `findById` in SupabaseRepository
- `update` in SupabaseRepository
- `updateSettings` in ServerRepository
- `setActive` in ServerRepository

### 2. Proper Data Preparation for Database Operations

When creating a new server configuration, we now exclude the 'id' field from the data sent to the database, allowing Supabase to generate a valid UUID:

```typescript
// Create a copy of defaultConfig without the 'id' field to avoid UUID validation errors
const configForDb = {
  guild_id: defaultConfig.guild_id,
  restricted_role_id: defaultConfig.restricted_role_id,
  admin_channel_id: defaultConfig.admin_channel_id,
  verification_channel_id: defaultConfig.verification_channel_id,
  admin_notification_role_id: defaultConfig.admin_notification_role_id,
  is_active: defaultConfig.is_active,
  settings: defaultConfig.settings,
};
```

## Best Practices for Supabase Error Handling

1. **Distinguish Between Error Types**:

   - 'PGRST116' (No rows returned) should be treated as a valid "not found" case
   - Other PostgrestError codes should be thrown as errors
   - Non-PostgrestError errors should be handled separately

2. **Data Validation Before Database Operations**:

   - Ensure data conforms to database schema requirements
   - Remove or transform fields that might cause validation errors
   - Let the database generate UUIDs and timestamps when possible

3. **Consistent Return Types**:

   - Methods should return null for "not found" cases, not throw errors
   - This allows higher-level code to handle missing data gracefully
   - Document the expected return types clearly in method comments

4. **Error Propagation**:
   - Use custom RepositoryError class to wrap database errors
   - Include the original error as the cause for debugging
   - Provide context about the operation that failed

## Implementation Checklist

When implementing new repository methods:

- [ ] Handle 'PGRST116' errors as "not found" cases
- [ ] Validate data before sending to database
- [ ] Remove fields that should be generated by the database
- [ ] Return null for "not found" cases
- [ ] Wrap errors with context using RepositoryError
- [ ] Document expected behavior in method comments

## Related Components

- **SupabaseRepository**: Base implementation for all Supabase repositories
- **ServerRepository**: Server-specific repository implementation
- **ConfigService**: Uses ServerRepository to manage server configurations
- **RepositoryError**: Custom error class for repository operations

## Testing Error Handling

### Test Case Implementation

1. **Mock Setup**:

```typescript
// Import PostgrestError type
import { PostgrestError } from '@supabase/supabase-js';

// Mock error response with proper structure
const mockError = {
  message: 'Database error',
  details: '',
  hint: '',
  code: 'PGRST301',
} as PostgrestError;

// Mock Supabase response
const mockOrder = jest.fn().mockResolvedValue({
  data: null,
  error: mockError,
});
```

2. **Error Assertions**:

```typescript
// Test that errors are properly thrown with context
await expect(repository.findByServerAndUser('server1', 'user1')).rejects.toThrow(
  'Database error during findByServerAndUser: Database error'
);
```

3. **Not Found Cases**:

```typescript
// Mock "not found" response
const mockSingle = jest.fn().mockResolvedValue({
  data: null,
  error: { code: 'PGRST116' },
});

// Test that null is returned for not found
const result = await repository.findById('123');
expect(result).toBeNull();
```

### Best Practices for Testing

1. Always include proper error structure in mocks
2. Test both error and success paths
3. Verify error messages include method context
4. Handle "not found" cases as valid responses
5. Clean up mocks between tests
6. Test error handling for all repository methods

## Implementation Checklist

When implementing new repository methods:

- [ ] Handle 'PGRST116' errors as "not found" cases
- [ ] Validate data before sending to database
- [ ] Remove fields that should be generated by the database
- [ ] Return null for "not found" cases
- [ ] Wrap errors with context using RepositoryError
- [ ] Document expected behavior in method comments
